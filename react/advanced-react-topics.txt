React 19.2 latest features 
https://dev.to/elvissautet/react-192-just-dropped-what-actually-matters-my-3-week-production-test-5387

React 19 latest features
https://react.dev/blog/2024/12/05/react-19

React hooks cheatsheet:
https://www.tapascript.io/books/react-hooks-cheatsheet


1. Support for async functions in transitions to handle pending states, errors, forms and optimistic updates (introduced in React 18)
   const [isPending, startTransition] = useTransition();
   /* Handles pending state */
   startTransition(async() => {
      const response = await getData();
      return response.data;
   })

2. New hook useActionState()
   Simplifies form submission by automatically managing pending, success, error states.
   
   const submitDataAction = async (prevState, formData) => {
      formData.get('email') // Get email input
      try {
         await axios.post(formData);
         return {success: true}
      } catch (e) {
         return {error: e.message}
      }
   }
   const [state, formAction, isPending] = useActionState(submitDataAction, { success: false, error: null });
   

   <form action={formAction}>
      <input name="email" />
      <button disabled={isPending}>Submit</button> 
   </form>

3. New hook useFormStatus() - reads status of the parent form (useful when submit button is a separate child component, so no need to pass any props)
   const { pending, data, method, action } = useFormStatus();
   <button disabled={pending} >Submit</button>

4. New hook useOptimistic() - immediately render optimisticName while the async request is in progress.
   When update finishes or errors, React automatically switches to the currentName value.
   const [ optimisticName, setOptimisticName ] = useOptimistic(currentName)

5. New API use() - read a promise or context with use and React will suspend until the promise resolves 
   use is preferred over useContext as use can be called within if statement
   use(Promise)
   use(Context)

6. Improvements 
   - ref as a prop instead of forwardRef 
   - cleanup function from ref callbacks 
   - Support for document metadata 
   - Support for stylesheet precedence, preloading, prefetch assets, async script tags 
   

==========================================================================

1. React advanced hooks 
   a) useDeferredValue  https://react.dev/reference/react/useDeferredValue
   b) useTransition https://blog.webdevsimplified.com/2022-04/use-transition
      -> useDeferredValue is suited for optimizing rendering (show old content while fresh content is loading)
      -> useTransition gives lower priority to state updates written within startTransition to prevent blocking, so UI doesn't freeze 
      (Without useTransition, React treats every update as urgent so results in blocking UI)
   c) useId (Assign unique id to div etc when component is called multiple times)
   d) useImperativeHandle (Expose only few methods/custom methods from child component's forwardRef)
   e) useInsertionEffect (fired synchronously before DOM mutations eg. runtime injection of style tag)
   f) useLayoutEffect (fired synchronously after DOM mutation)
   g) useEffect (runs asynchronously once browser paints DOM changes to screen)

   React has 3 phases - Trigger, Render and Commit. 
   1. Trigger phase: re-render based on state/props/context/forceUpdate or initial render 
   2. Render phase: 
      - calculate virtual DOM 
      - Call useInsertionEffect       
   3. Commit phase: 
      - DOM mutation (update real DOM)
      - call useLayoutEffect (runs synchronously)
      - paint real DOM in UI 
      - call useEffect (after paint, side effects)

   Other hooks
    useState v/s useReducer - useReducer is better choice when multiple vars need to be managed 
    eg. {loading: false, data:[], eror: null } instead of 3 useState
    useContext - used as consumer to read value of Context
    useRef (v/s useState) - doesn't rerender component

2. forwardRef with useImperativeHandle (Create ref in parent and send to child component i.e access child's ref from parent)
   https://codesandbox.io/p/sandbox/forwardref-rmzmz6

3. React memo - Re-render child component only if props have changed.
   memo(Component, arePropsEqual)  --> arePropsEqual internally uses Object.is to compare old and new props
   It compares the current props with the next props using Object.is for primitive values and a shallow equality check for objects. 
   // For comparing object props, create a custom equality function
   const arePropsEqual = (prevProps, nextProps) => {
      return JSON.stringify(prevProps) === JSON.stringify(nextProps);
   };
   memo(Component, arePropsEqual);
   https://codesandbox.io/p/sandbox/memo-eg-qmchpg
   https://codesandbox.io/p/sandbox/react-memo-object-props-iimgcg

4. useMemo & useCallback 
   - useMemo - cache function result for dependencies. Function will be called only when there's a change in dependency value
   - useCallback - caches function itself when passed as prop to child 
   Note: In below example, useMemo and useCallback solves the same purpose. 
   const clickHandlerChildMemo = useMemo(() => {
      return clickHandlerChild();
   }, [childName]);
   const clickHandlerChildCallback = useCallback(
     () => clickHandlerChild,
     [childName],
   );
   https://codesandbox.io/p/sandbox/react-memo-hooks-m8p9hr
   
5. What is React Fiber?
   https://sunnychopper.medium.com/what-is-react-fiber-and-how-it-helps-you-build-a-high-performing-react-applications-57bceb706ff3
   Fiber is the new Reconcialiation algorithm in React.
   (Work - any computations that must be performed. It's usually the result of an update eg. setState)
   - pause work and come back to it later
   - assign pririoty to different types of work
   - reuse previously completed work
   - abort work if it's no longer needed
   https://github.com/acdlite/react-fiber-architecture
   https://flexiple.com/react/react-fiber

6. React authentication and authorization 
   https://dev.to/miracool/how-to-manage-user-authentication-with-react-js-3ic5
   - ProtectedRoute - mention nested routes
   - useAuth - custom hook which returns Provider with object values and reusable functions
   // Route 
   <Route element={<ProtectedRoute />}>
     <Route path="/dashboard" element={<Dashboard />} />
     <Route path="/profile" element={<Profile />} />
   </Route>
   // ProtectedRoute component - redirect to /login if token is not found
   export const ProtectedRoute = () => {
      const { token } = useAuth();
      if (token) return <Navigate to="/login">;
      return <Outlet />;
   }

   Access token = short-lived, stored in memory (not accessible after refresh)
   Refresh token = in HttpOnly cookie, auto-sent with requests
   Refresh API issues new access + refresh tokens
   Backend invalidates old refresh token

   Use BroadcastChannel so that when one tab refreshes the token, the other tabs refresh it instantly. 

7. Why does useEffect not support direct async callback function?
Ans: It expects its return function to either return a cleanup function or nothing at all. 
If we declare callback function as async, it implicitly returns a Promise, which React doesn't recognize as a clean up function. This can cause issue as React expects cleanup function to be a function and not a Promise. 

8. Disadvantage of using state in Context?
Ans: If there are multiple nested components within parent Context.Provider, state update would cause re-render to all components that are consuming this Context. So it's a good practice to wrap the Context close to the component we want to re-render.  Only components that call useContext re-render whenever the context’s state changes. 
Solution: Use Multiple Contexts, and keep state close to its Dependent Components

========================================================================

React 19.2 latest features:
1. Activity component - two modes visible and hidden 
   hidden - hides the children and unmounts effects 
   visible - shows the children and mounts effects 
   Use Case: it preserves the component state, scroll position etc (useState, useRef)
   In Activity, the component stays mounted but React pauses its effects and deprioritizes updates — saving performance while preserving state.

   <Activity mode={tabName == 'profile' ? 'visible' : 'hidden'}>
      <Profile />
   </Activity>
   <Activity mode={tabName == 'dashboard' ? 'visible' : 'hidden'}>
      <Dashboard />
   </Activity>

2. useEffectEvent - use latest state, props inside an effect without re-running the effect every time 

useEffect(() => {
   const fetchData = async() => {
      const res = await api.getData(userId, sortBy);
      setData(res);
   };
   fetchData();
}, [userId, sortBy]);

// Always uses the latest sortBy value
const fetchData = useEffectEvent(async() => {
      const res = await api.getData(userId, sortBy);
      setData(res);
});
// Effect runs only when userId is changed
useEffect(() => {
   fetchData();
}, [userId]);

3. Partial pre-rendering: combines the benefits of SSG (Static Site generation) and SSR (Server side rendering). 
Static contents generated at build time are loaded immediately. 
Dynamic parts (personalized data or API results) are loaded on demand and streamed in once ready.
   
4. Batching suspense boundaries for SSR - reveal more content together instead of one by one. Earlier, server-rendered suspense loaded one by one but client-rendered suspense loaded in batch, so it felt janky.

=============================

In React 19, React Compiler is introduced which checks the code during build time and adds memoization code wherever necessary to avoid re-render. It thus eliminates the use of useMemo, useCallback, React.memo manually in most cases.
Edge cases e.g. external dependencies 3rd party like Maps library 

const markerClickHandler = useCallback((markerId) => {
   // Logic
}, []);
return <Map onMarkerClick={markerClickHandler} />
   
   
   
