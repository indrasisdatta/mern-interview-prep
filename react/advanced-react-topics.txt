React 19.2 latest features 
https://dev.to/elvissautet/react-192-just-dropped-what-actually-matters-my-3-week-production-test-5387

React 19 latest features
https://react.dev/blog/2024/12/05/react-19

React hooks cheatsheet:
https://www.tapascript.io/books/react-hooks-cheatsheet


1. Support for async functions in transitions to handle pending states, errors, forms and optimistic updates (introduced in React 18)
   const [isPending, startTransition] = useTransition();
   /* Handles pending state */
   startTransition(async() => {
      const response = await getData();
      return response.data;
   })

2. New hook useActionState()
   Simplifies form submission by automatically managing pending, success, error states.
   
   const submitDataAction = async (prevState, formData) => {
      formData.get('email') // Get email input
      try {
         await axios.post(formData);
         return {success: true}
      } catch (e) {
         return {error: e.message}
      }
   }
   const [state, formAction, isPending] = useActionState(submitDataAction, { success: false, error: null });
   

   <form action={formAction}>
      <input name="email" />
      <button disabled={isPending}>Submit</button> 
   </form>

3. New hook useFormStatus() - reads status of the parent form (useful when submit button is a separate child component, so no need to pass any props)
   const { pending, data, method, action } = useFormStatus();
   <button disabled={pending} >Submit</button>

4. New hook useOptimistic() - immediately render optimisticName while the async request is in progress.
   When update finishes or errors, React automatically switches to the currentName value.
   const [ optimisticName, setOptimisticName ] = useOptimistic(currentName)

5. New API use() - read a promise or context with use and React will suspend until the promise resolves 
   use is preferred over useContext as use can be called within if statement
   use(Promise)
   use(Context)

6. Improvements 
   - ref as a prop instead of forwardRef 
   - cleanup function from ref callbacks 
   - Support for document metadata 
   - Support for stylesheet precedence, preloading, prefetch assets, async script tags 
   

==========================================================================

1. React advanced hooks 
   a) useDeferredValue  https://react.dev/reference/react/useDeferredValue
   b) useTransition https://blog.webdevsimplified.com/2022-04/use-transition
      -> useDeferredValue is suited for optimizing rendering (show old content while fresh content is loading)
      -> useTransition gives lower priority to state updates written within startTransition to prevent blocking, so UI doesn't freeze 
      (Without useTransition, React treats every update as urgent so results in blocking UI)
   c) useId (Assign unique id to div etc when component is called multiple times)
   d) useImperativeHandle (Expose only few methods/custom methods from child component's forwardRef)
   e) useInsertionEffect (fired synchronously before DOM mutations eg. runtime injection of style tag)
   f) useLayoutEffect (fired synchronously after DOM mutation)
   g) useEffect (runs asynchronously once browser paints DOM changes to screen)

   React Execution Timeline
   1) Render Phase: React calculates the Virtual DOM (no browser changes yet).
   2) Commit Phase (Sub-beat 1): useInsertionEffect
      When: Before DOM nodes are moved/inserted into the real browser DOM.
      Purpose: Injecting dynamic CSS (like CSS-in-JS libraries). By doing it here, the browser doesn't have to recalculate styles multiple times during the actual DOM mutation.
   3) Real DOM Update: React updates the actual browser elements.
   4) Commit Phase (Sub-beat 2): useLayoutEffect
      When: Synchronously after the DOM is updated, but before the browser paints the screen.
      Purpose: Measuring layout (getting element width/height) or making a change that must happen before the user sees anything (to avoid flickering).
   5) Browser Paint: The user actually sees the pixels on the screen.
   6) After Paint: useEffect
      When: Asynchronously after the paint.
      Purpose: Most side effects (API calls, subscriptions, setting up event listeners). It doesn't block the UI.

   Other hooks
    useState v/s useReducer - useReducer is better choice when multiple vars need to be managed 
    eg. {loading: false, data:[], eror: null } instead of 3 useState
    useContext - used as consumer to read value of Context
    useRef (v/s useState) - doesn't rerender component

2. forwardRef with useImperativeHandle (Create ref in parent and send to child component i.e access child's ref from parent)
   https://codesandbox.io/p/sandbox/forwardref-rmzmz6

3. React memo - Re-render child component only if props have changed.
   memo(Component, arePropsEqual)  --> arePropsEqual internally uses Object.is to compare old and new props
   It compares the current props with the next props using Object.is for primitive values and a shallow equality check for objects. 
   // For comparing object props, create a custom equality function
   const arePropsEqual = (prevProps, nextProps) => {
      return JSON.stringify(prevProps) === JSON.stringify(nextProps);
   };
   memo(Component, arePropsEqual);
   https://codesandbox.io/p/sandbox/memo-eg-qmchpg
   https://codesandbox.io/p/sandbox/react-memo-object-props-iimgcg

4. useMemo & useCallback 
   - useMemo - cache function result for dependencies. Function will be called only when there's a change in dependency value
   - useCallback - caches function itself when passed as prop to child 
   Note: In below example, useMemo and useCallback solves the same purpose. 
   const clickHandlerChildMemo = useMemo(() => {
      return clickHandlerChild();
   }, [childName]);
   const clickHandlerChildCallback = useCallback(
     () => clickHandlerChild,
     [childName],
   );
   https://codesandbox.io/p/sandbox/react-memo-hooks-m8p9hr
   
5. What is React Fiber?
   https://sunnychopper.medium.com/what-is-react-fiber-and-how-it-helps-you-build-a-high-performing-react-applications-57bceb706ff3
   Fiber is the new Reconcialiation algorithm in React.
   (Work - any computations that must be performed. It's usually the result of an update eg. setState)
   - pause work and come back to it later
   - assign pririoty to different types of work
   - reuse previously completed work
   - abort work if it's no longer needed
   https://github.com/acdlite/react-fiber-architecture
   https://flexiple.com/react/react-fiber

6. React authentication and authorization 
   https://dev.to/miracool/how-to-manage-user-authentication-with-react-js-3ic5
   - ProtectedRoute - mention nested routes
   - useAuth - custom hook which returns Provider with object values and reusable functions
   // Route 
   <Route element={<ProtectedRoute />}>
     <Route path="/dashboard" element={<Dashboard />} />
     <Route path="/profile" element={<Profile />} />
   </Route>
   // ProtectedRoute component - redirect to /login if token is not found
   export const ProtectedRoute = () => {
      const { token } = useAuth();
      if (token) return <Navigate to="/login">;
      return <Outlet />;
   }

   Access token = short-lived, stored in memory (not accessible after refresh)
   Refresh token = in HttpOnly cookie, auto-sent with requests
   Refresh API issues new access + refresh tokens
   Backend invalidates old refresh token

   Use BroadcastChannel so that when one tab refreshes the token, the other tabs refresh it instantly. 

7. Why does useEffect not support direct async callback function?
Ans: It expects its return function to either return a cleanup function or nothing at all. 
If we declare callback function as async, it implicitly returns a Promise, which React doesn't recognize as a clean up function. This can cause issue as React expects cleanup function to be a function and not a Promise. 

8. Disadvantage of using state in Context?
Ans: If there are multiple nested components within parent Context.Provider, state update would cause re-render to all components that are consuming this Context. So it's a good practice to wrap the Context close to the component we want to re-render.  Only components that call useContext re-render whenever the context‚Äôs state changes. 
Solution: Use Multiple Contexts, and keep state close to its Dependent Components

========================================================================

React 19.2 latest features:
1. Activity component - two modes visible and hidden 
   hidden - hides the children and unmounts effects 
   visible - shows the children and mounts effects 
   Use Case: it preserves the component state, scroll position etc (useState, useRef)
   In Activity, the component stays mounted but React pauses its effects and deprioritizes updates ‚Äî saving performance while preserving state.

   <Activity mode={tabName == 'profile' ? 'visible' : 'hidden'}>
      <Profile />
   </Activity>
   <Activity mode={tabName == 'dashboard' ? 'visible' : 'hidden'}>
      <Dashboard />
   </Activity>

2. useEffectEvent - use latest state, props inside an effect without re-running the effect every time 

useEffect(() => {
   const fetchData = async() => {
      const res = await api.getData(userId, sortBy);
      setData(res);
   };
   fetchData();
}, [userId, sortBy]);

// Always uses the latest sortBy value
const fetchData = useEffectEvent(async() => {
      const res = await api.getData(userId, sortBy);
      setData(res);
});
// Effect runs only when userId is changed
useEffect(() => {
   fetchData();
}, [userId]);

3. Partial pre-rendering: combines the benefits of SSG (Static Site generation) and SSR (Server side rendering). 
Static contents generated at build time are loaded immediately. 
Dynamic parts (personalized data or API results) are loaded on demand and streamed in once ready.
   
4. Batching suspense boundaries for SSR - reveal more content together instead of one by one. Earlier, server-rendered suspense loaded one by one but client-rendered suspense loaded in batch, so it felt janky.

=============================

In React 19, React Compiler is introduced which checks the code during build time and adds memoization code wherever necessary to avoid re-render. It thus eliminates the use of useMemo, useCallback, React.memo manually in most cases.
Edge cases e.g. external dependencies 3rd party like Maps library 

const markerClickHandler = useCallback((markerId) => {
   // Logic
}, []);
return <Map onMarkerClick={markerClickHandler} />


Re-rendering logic for Context:
- When Provider re-renders ‚Üí All children re-render (unless wrapped in React.memo)
- When Provider‚Äôs value changes ‚Üí All useContext() consumers re-render
(React.memo CANNOT prevent it)   
   
flushSync - synchronous update to the DOM 
https://www.dhiwise.com/post/understanding-react-flushsync-a-deep-dive-into-synchronous-rendering

state is updated and the component is re-rendered immediately, without waiting for other pending updates.

==================

IMP: React internals (For understanding)

Reconciliation - process used by React to update UI efficiently 

Virtual DOM is the conceptual model (the what)
Fiber is the engine for reconciliation (the how)

React <= v15 - The reconciliation process was a synchronous, recursive process. Once it started, it couldn't be interrupted, which could lead to blocking the main thread and janky user experience for large updates.

React >= 16 - Fiber is a complete rewrite of the core reconciliation algorithm. It breaks the work into small units (Fibers) that can be scheduled, paused, and prioritized. This enables the new features: Concurrent Mode and prioritized/async updates.

React 18 onwards we had the shift from synchronous to concurrent rendering. 
Fiber was introduced in 16 itself but it still supported synchronous rendering to maintain backwards compatibility.

                  Stack Reconciler (Old)    Fiber Reconciler (New) 
Work style           Recursive               Incremental 
Interruptible?       No                      Yes 
Prioritization?      No                      Yes 

   Incremental rendering - splits the big task of rendering into small units of work. Prevents jank by yielding control back to browser every few ms. 

   Concurrent rendering - allows React to prepare a new UI in the background while the old one stays interactive. 

Diffing - algo used by old React to compare old and new virtual DOM differences

Virtual DOM - JS objects representing UI for comparing changes (till React 15)

Fiber - React's new Reconciation system which breaks the reconciliation work down into small, interruptible units (the Fiber Nodes) and allows React to pause, resume, and prioritize updates. This is known as Concurrent Rendering and is enabled by the Fiber architecture.

  - Current tree (old VDOM state)
  - Work in Progress tree (new VDOM state is calculated)

Phases: 
 - Render: perform the entire calculation of updates in the background (can be paused, interrupted) 
 - Commit: commit the final changes to the real DOM (cannot be paused, interrupted) 

Fiber tree - data structure used by React to track UI updates 

Lane - React uses a system of Lanes to manage and prioritize work. 
Fiber scheduler works on the highest-priority lane first. 

onChange = () => setState('123') // SyncLane (highest priority)
setTimeout // default lane (normal priority)
startTransition // TransitionLane (lower priority)

=========

My understanding on Fiber architecture: 

   In old React version (before 16), they used Stack Reconciler where rendering process was recursive.

   React 16 onwards, Fiber was introduced. It was only till React 18 that all Fiber features were unlocked - concurrent rendering, incremental rendering, automatic batching updates, prioritizing state updates. React 16 and 17 still supported synchronous rendering (not concurrent) to maintain backwards compatibility.

Key terms:
   - Incremental rendering: break up large rendering process into small units of work, so that the control is back to the browser every few milliseconds

   - Concurrent rendering: allows React to prepare new UI in the background while keeping old UI interactive

   - Prioritizing updates: Use Lanes to check priorities e.g. SyncLane for onClick and onChange handler has highest priority, TransitionLane for startTransition has lowest priority

Fiber maintains 2 trees: current tree and WIP tree.

Render phase:
 - It traverses each node in the WIP tree, runs beginWork and completeWork and maintains an effect list (LinkedList).  
 - React uses Depth first searh (DFS) LinkedList traversal rather than recursion 
 - beginWork() called as React goes down the tree. It determines if component needs update and tags it for changes. 
 - completeWork() called as React bubbles back up the tree. It creates real DOM nodes (but doesn't mount them yet) and handles the Effect list. 

Effect list - instead of searching the entire WIP tree again during the commit phase, React maintains a liner linked list of only the nodes that have effects (changes like insert/update/delete). This makes commit phase fast. 

Commit phase: 
   - Executes the changes in the effect list to the real DOM 
   - Swap - changes the root pointer from old current tree to newly finished WIP tree. So WIP tree now becomes current tree. 


Two phases:
   Render phase - calculate differences, rendering can be paused/cancelled
   Commit phase - changes are applied to the real DOM

=============================

üîπ Set 1 ‚Äì React 18/19 Concurrency & Scheduling Internals

1Ô∏è‚É£ Difference between legacy sync rendering vs concurrent rendering in React 18/19.
2Ô∏è‚É£ How the Fiber scheduler pauses, resumes, and abandons partial work.
3Ô∏è‚É£ What are lanes and how do they control priority of UI updates?
4Ô∏è‚É£ Why interruptible rendering is core to UX smoothness.
5Ô∏è‚É£ Why React runs useEffect twice in Strict Mode (dev only).
6Ô∏è‚É£ When to use useTransition to stop UI blockage.
7Ô∏è‚É£ useTransition vs startTransition with priority distinction.
8Ô∏è‚É£ How useDeferredValue avoids list & search lag.
9Ô∏è‚É£ What changed with Suspense in React 18 streaming pipeline.
üîü Why hydration mismatch happens even if server HTML = client render.

‚∏ª

üîπ Set 2 ‚Äì React 19 Hydration Model, Streams & Modern UI Delivery

1Ô∏è‚É£ How Progressive Hydration differs from full hydration in React 19.
2Ô∏è‚É£ What is Selective Hydration and why it hydrates only interaction-touched UI.
3Ô∏è‚É£ Explain React Flight (server ‚Üí client payload streaming).
4Ô∏è‚É£ What causes client waterfalls with mixed RSC & client components.
5Ô∏è‚É£ What is lazy hydration and how it boosts INP/LCP.
6Ô∏è‚É£ React 19‚Äôs partial serialization strategy in hydration.
7Ô∏è‚É£ Full vs Progressive vs Selective hydration ‚Äî when to choose each.
8Ô∏è‚É£ Why streaming helps UI render the shell first, details later.
9Ô∏è‚É£ How Suspense boundaries isolate slow UI to avoid blocking.
üîü Role of Offscreen Rendering in React 19 for background updates.

‚∏ª

üîπ Set 3 ‚Äì State, Rendering Boundaries & Re-Render Control

1Ô∏è‚É£ When state colocation beats lifting state (render scope control).
2Ô∏è‚É£ Why heavy Context leads to re-render storms & how to isolate with selectors.
3Ô∏è‚É£ Automatic Batching across events, promises & fetches in React 18.
4Ô∏è‚É£ Controlled vs Uncontrolled components from a render cost perspective.
5Ô∏è‚É£ Why referential stability (useRef, memo) matters for lists & grids.
6Ô∏è‚É£ Signals vs stores vs context ‚Äî why subscriptions reduce re-render floods.
7Ô∏è‚É£ How RSC boundaries eliminate client JS cost.
8Ô∏è‚É£ Why props look the same but still cause re-render (identity vs equality).
9Ô∏è‚É£ When to avoid lifting and rely on server-cached state instead.
üîü React 19 preparing ground for partial UI compilation & offscreen hydration.
