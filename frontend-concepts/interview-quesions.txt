1) JSON.stringify v/s structuredClone 
 structuredClone advantages:
 - structuredClone can handle circular references 
 - Date, Map, Set are preserved 
 - faster for complex objects 
 Use JSON.stringify for simple JSON compatible data (API payload, response)

2) Retry with exponential backoff 
 - Refer to fetchWithAutoRetry.js

3) Avoid updating state of unmounted components - AbortController 

4) Implement a custom debounce JS function 
 - Refer to pollyfills.js 
 
5) How to avoid full app re-render on theme change? 
 - Use CSS variables instead of React layer
 - useSyncExternalStore 

    // Without any React re-render
    useEffect(() => {
        document.documentElement.setAttribute("data-theme", theme);
    }, [theme]);

    /* CSS */
    :root[data-theme="light"] {
    --bg-color: #fff;
    --text-color: #000;
    }

6) CommonJS          v/s    ES Module 
   require, exports       import/export
   synchronous            asynchronous
   cached by default      not cached by default 
   useful in server-side  both client & server side
   (Node)
   dynamic import X       supports dynamic import 
                          (useful for lazy or conditional loading)
   Tree shaking X         tree shaking is supported 
   Legacy NodeJS projects Modern Node JS BE projects with "type": "module"
                          frontend apps with webpack, vite, Next.js 

Note: Old jest.config and eslint.config before Node 20 supported only CommonJS with module.exports syntax 

   