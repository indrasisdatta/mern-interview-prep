WEB OPTIMIZATION

	Loading time includes:
	 - TTFB (Time to first byte) 
	 - FCP (First contentful paint)
	 - LCP (Last contentful paint)
	 - TTI (Time to interactive) 
	 
	How to improve TTFB? (Goal: Process server request fast and deliver to client fast)
	 - Use CDN to serve static files
	 - Optimize server side processing (eg. DB queries) 
	 - Optimize DNS lookup times with DNS prefetching 
	 - Enable compression (Gzip, Brotli) to reduce response size 
	 - Use Redis to cache heavy responses 
	 - Use HTTP/2 or HTTP/3 for multiplexing or lower latency 
	 - Reduce HTTP overhead by minimizing headers and cookies 

	How to improve FCP? (Pre-loading or cache for above-the-fold content i.e before scollbar content and lazy load the rest) 
	PRPL Pattern
	 - Preload the late-discovered resources   <link rel="preload" as="image" href="image.jpg" > 
	 - Render the initial route as soon as possible (inline critical JS and set others as async, inline critical CSS used above the fold, server-side rendering but can harm TTI time to interactive)
	 - Pre-cache remaining assets (service workers)
	 - Lazy load other routes and non-critical assets (split your bundle)
	https://web.dev/articles/apply-instant-loading-with-prpl
	 
	How to improve LCP? 
	 - Optimize images using modern formats (avif, webp), compression and lazy loading 
	 - Don't lazy load above the fold images to avoid delay in LCP 
	 - JS optimizations - reduce bundle size (tree shaking, code splitting), delay or async load non-critical JS 
	 
	How to improve TTI? 
	 - Break down long-running JS tasks (Use web workers for heavy computation, split tasks using setTImeout, requestIdleTimeout )
	 - Prioritize loading essential scripts first 
	 - Minimize 3rd party scripts that may be blocking interactivity
	 - Server side rendering (SSR, hydration, static rendering) 
	 - Preload resources based on user behaviour 
	 
	Backend communication - long polling, server-sent events (SSE), web sockets 

	For smooth animation:
	  - Use GPU Acceleration (Use GPU friendly CSS properties like transform and opacity)
	  - Prefer CSS animation 
	  - Use the composion thread/explicit layer creation 
	  
	GPU animations don't trigger re-layouts and re-paints since they are handled at composition layer 

=======================================

Is lazy loading not supported in SSR? 
Full page reloads 

SSR, CSR, SSG, Pre-rendering 

Case Study 1: Social Network
 - Public faced website with millions of DAU 
   (SEO needed, must start quickly, work on low powered devices, UI should be smooth and fast)
 - Content is dynamically rendered 
Solution: SSR with hydration 
Uncanny valley - inspite the page is render and looks normal, it's not interactive. Hydration types: 
 - Full hydration (request the full JS bundle once and hydrate the application)  
 - Partial/selective hydration (hydrate only interactive parts of the aplication)
 - Progressive hydration (individually hydrate nodes over time)
 Island architecture - similar to Partial hydration. Divide the page into independent interactive static components that can be rendered and updated separately. 
https://www.patterns.dev/vanilla/islands-architecture/

Import on interaction - Different ways to load resources: 
- lazy (route based)
- lazy (on interaction) - load when user clicks the UI eg. YouTube video 
- lazy (in viewport) - when user scrolls towards the component 
- Prefetch - load prior to needed but after critical resources are loaded 
- Preload - eagerly with a great level of urgency
https://www.patterns.dev/vanilla/import-on-interaction

Import on visibility - lazy load images that are not directly visible in the viewport but only get loaded when user scrolls down 
Use IntersectionObserver API or use libraries like react-lazyload or react-loadable-visibility 

RESOURCE HINTS:
https://web.dev/learn/performance/resource-hints
 - preload (Load resource right now needed immediately eg. fonts, main js)
 - prefetch (Load resource in background eg. next page, other route assets)
 - preconnect (DNS resolution, open TCP, TLS handshake eg. CDN, fonts)
 - dns-prefetch (DNS resolution eg. )
 - pre-render (Load and render an entire page in a hidden tab anticipating users will visit. Very powerful but heavy.)
 - module-preload (Preload ES modules and dependencies before execution)

Normally, the browser calculates layout + paint for everything on the page, even elements far below the fold.
.card {
	content-visibility: auto; // Doesn't render until needed 
	contain-intrinsic-size: 300px;
}

Prefetch:
const EmojiPicker = import(/* webpackPrefetch: true */ "./EmojiPicker");

Prevent layout shifting and flashes of unstyled text by preloading optional fonts 
<link rel="preload" href="pacifico.woff2" as="font" crossorigin="anonymous">
@font-face {
  font-family: 'Pacifico';
  font-style: normal;
  font-weight: 400;
  src: local('Pacifico Regular'), local('Pacifico-Regular'), url(pacifico.woff2) format('woff2');
  font-display: swap;
}

 <link rel="dns-prefetch" href="https://www.google.com">
 <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>

 When a browser first contacts a new domain eg. google.com, it does: 
 Step 1: DNS resolution - look up domain's IP address 
 Step 2: Open TCP connection
 Step 3: Negotiate TLS (HTTPS handshake)

 dns-prefetch does step 1 while the page is still loading 
 preconnect does step 1, 2, 3 (Reduces time to first byte TTFP for subsequent requests)

 These are used in Google fonts and CDNs.

COMPRESSION: brotli, gzip (done at server-side Node.js, nginx)

List virtualization:
 react-virtualized 
 react-window (rewrite of react-virtualized to be smaller, faster)

CRACO - Create react app configuration override (without eject)

===================

ASSET OPTIMIZATION TECHIQUES:

1) Image 
   https://medium.com/@arulvalananto/9-image-optimization-tricks-for-a-seamless-web-experience-b41867e87e54
   - WebP, AVIF  <img srcset="image.webp image.jpg" src="image.jpg" /> 
   - Responsive images (provide multiple sizes, browser chooses the best match)  
   - Adaptive images (served based on connection speed)
   - Blur-up placeholder (show a tiny blurred placeholder image first)
   - CSS image sprites
   - lazy loading 
   - CDN image compression (Cloudflare, Akamai, Cloudinary)

   Responsive example:
   <img src="image.jpg"
     srcset="
		image-small.jpg 480w,
		image-medium.jpg 800w,
		image-large.jpg 1200w
	 "
	 sizes="(max-width: 600px) 480px, 800px"
	/>
 
2) Video 
   - Progressive enhancement (use webM) 
   - Replace gifs with videos 
   - Responsive poster image 
   - Streaming (HLS/DASH delivery large videos in chunks, only downloaded when users watch) 
   - Videos with no audio 
   - Preload 

3) Fonts 
   https://blog.pixelfreestudio.com/how-to-optimize-web-fonts-for-faster-loading-times/
   - font-display: swap (No invisible text, load system font first, switch to custom font later)
   - preload critical font
   <link rel="preload" href="main.woff2" as="font" type="font/woff2" crossorigin>
   - Progressive enhancement (use woff2 first and woff as fallback)
   - Use only needed font variants (eg. 400, 600 instead of 100-900)
   - font face observer (JS library which detects when fonts finish loading)
     	const font = new FontFaceObserver("MyFont");
		font.load().then(() => {
		document.body.classList.add("font-loaded");
		});
   - Self host fonts instead of Google fonts

4) CSS 
   - critical CSS rendering (Above the fold CSS)
   - lazy loading (browser downloads the CSS early but doesn't block rendering)   

   <link rel="preload" href="style.css" as="style" onload="this.rel='stylesheet'" />
   <noscript>
	<link rel="stylesheet" href="style.css" />
   </noscript>
 
5) JS 
   - defer v/s async 
   - web worker 
   - lazy loading

==============================================

Adaptive Bitrate Streaming (ABS): video is split into small chunks at multiple quality levels and the player adjust quality based on the network speed.
Uses HLS, DASH. No buffering, smooth playback. Quality 144p, 480p, 1080p etc. 

Progressive Video Download: video is downloaded from start to end and starts playing once enough data is buffered (Eg. MP4 file, not chunked)


Netflix architecture (SEO driven, dynamic, media-heavy) - Next.js is the best choice 
 - SSR/ISR 
 - Image optimization (automatic compression, resize, lazy load, serves webp/avif from Vercel's Edge CDN cache)
 - Edge middleware (small serverless function running on Vercel's edge nodes close to the user, before request hits the route. Used for auth check, geo-based personalization, device based redirects m.example.com)
 - Routing (file-based routing)
 - Performance primitives (tree shaking, code splitting, prefetch links on hover/viewport, SSG)

For self hosted (Docker on EC2 instead of Vercel):
- Image optimization 
   Approach 1: install sharp so that Next.js can do webp, avif conversion (image is uploaded in this server itself)
   Approach 2: use external image CDN (eg. Cloudflare images) by updating next.config.js image loader and path options  

- Edge middleware 
	Cloudfront + Lambda@Edge 
Note: Next.js edge middleware runs on edge runtime, which is available on Vercel's edge network or Cloudflare workers. EC2 can't run edge functions.


