NodeJS 24 latest features
https://blog.codeminer42.com/whats-new-in-node-js-24/

Node JS process 

Main thread:
 - init project 
 - top level code 
 - require module 
 - event callback register
 - start event loop 
 - offload CPU intensive tasks to thread pool (File system, Crypto (encrypt/decrypt, Compression)

Event loop phases:
1) Timers: Expired timer callbacks setTimeout, setInterval 
2) Pending callbacks: callbacks that couldn't be executed in the previous loop iteration are executed here
3) Poll: I/O polling FS 
4) Check: setImmediate() callback 
5) close callbacks (server/socket close CB)
Any tasks pending? true then exit, otherwise restart event loop 

Promise callback - executed during event loop transition 

setTimeout() and setImmediate() order is non-deterministic at top level code. 
Inside I/O callback, setImmediate() is executed first 

Call stack -> process.nextTick() -> promise microtasks -> event loop phases

https://www.linkedin.com/pulse/mastering-event-loop-tricky-node-interview-questions-aayush-patniya-lbobf


The Workflow Lifecycle
1) Code Input: You run your script. V8 parses the code and puts functions on the Call Stack.
2) Async Offloading: If the code calls an async function (e.g., fs.readFile), Libuv takes over. It sends the task to the Worker Pool or the OS kernel.
3) The Wait: The Main Thread is now free to keep running other code. It does not wait for the file to finish reading.
4) Completion: Once the Worker Pool finishes the task, it pushes the callback function into the Event Queue.
5) The Event Loop: This is a continuous loop. It checks: "Is the Call Stack empty?" If yes, it takes the first task from the Event Queue and pushes it onto the Call Stack to be executed.

Call stack 
Event queue/Callback queue 
Microtask queue