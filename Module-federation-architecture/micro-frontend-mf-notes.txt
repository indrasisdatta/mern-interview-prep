Micro-Frontend: 
- App is split into independent modules and deployed separately 
  (e.g. Search, Booking, Payment made in different technologies)
- Host application loads the layout, navbar, routing 
- Remote applications (SearchApp, BookingApp) are exposed via bundles via Module Federation
- Host dynamically loads remote apps at runtime based on the URL 

MF Architecture patterns:
1) Build time integration - child app is published as npm packege and host app imports it (similar to any other dependency).
    // remote app does npm publish 
    export const CheckoutButton = () => {
    return <button>Pay Now</button>;
    };

    // host app imports
    import { CheckoutButton } from '@my-org/checkout';

2) Run time integration 
    - loads MF bundles dynamically at runtime
    - uses Webpack Module Federation

3) Server-side composition 
    - the shell server fetches HTML fragments from MFs 
    - assembles into a single response 
    - sends it to the browser.

4) Edge-side composition
    - the edge CDN (near the user loation) fetches HTML fragments from MFs 
    - assembles into a single response 
    - sends it to the browser.

Communication among remote apps? 
Common libs? Where to keep (in host?) and how to reuse?


MICRO FRONTEND (MODULE FEDERATION) â€“ LIMITATIONS & REMEDIES

1) Shared State Management

    Problem:
        Global Redux across micro frontends is hard to manage
        Causes tight coupling between apps

    Remedies: Keep state local to each micro frontend
    Communicate using:
        Custom browser events
        RxJS event bus
        URL state or backend as source of truth

2) CSS Conflicts

    Problem: Styles can leak between micro frontends

    Remedies:
        CSS Modules
        Scoped CSS / BEM
        Shadow DOM (when suitable)
        Shared design system or design tokens

3) CI/CD Complexity

    Problem:
        Each micro frontend needs its own pipeline
        Deployment coordination becomes complex

    Remedies:
        Independent CI/CD per micro frontend
        Backward-compatible contracts
        Clear ownership per team

4) Initial Load Performance

    Problem:
        Multiple remote entry files
        Network request waterfall

    Remedies:
        Lazy load micro frontends
        Preload critical remotes
        Use CDN caching
        Share common dependencies carefully

5) Version Compatibility

    Problem:
        React or shared library version mismatch
        Breaking changes at runtime

    Remedies:
        Strict versioning rules
        Semantic versioning
        Minimize shared dependencies

6) Debugging Complexity

    Problem:
        Errors span across multiple apps
        Harder stack traces and source maps

    Remedies:
        Enable source maps
        Centralized logging and monitoring
        Error boundaries per micro frontend

7) Runtime Failures

    Problem:
        Remote app unavailable
        Bad deployment breaks host at runtime

    Remedies:
        Graceful fallbacks
        Feature flags
        Timeout and retry logic

8) Over-Engineering Risk
    Problem: Too much complexity for small teams or apps

    Remedy: Use micro frontends only when:
        Multiple teams are involved
        Independent deployments are required
        Product is large and long-lived

SUMMARY:
Micro frontends scale teams and deployments but increase architectural
and operational complexity. Use them only when scale demands it.

=================

What if a remote MF goes down? 
 - Error boundaries for each MF to handle runtime errors
    <ErrorBoundary fallback={<Fallback />}>
        <RemoteMF />
    </ErrorBoundary>

 - Dynamic import handles load failure - handles unreachable remoteEntry.js
    import("checkoutApp/Checkout").catch(() => showFallback());

 - Version pinning 
    - Every time a remote app is built, it's uploaded to CDN path: /checkout/v1.3.3/remoteEntry.js
    - Host uses env var CHECKOUT_MF_URL = /checkout/v1.3.3/remoteEntry.js
    - Host uses env var to detect remote URL
        // webpack.config.js (host)
        remotes: {
            checkoutApp: `checkoutApp@${process.env.CHECKOUT_MF_URL}`
        }
    - Once tested, host env can be updated to new version. In case of errors, rollback to previous version.

How to implement code splitting and lazy loading in MFA? 

Testing 
 - Unit testing at component level 
 - Integration testing using MSW in host app 

Security 
 - Runtime integration loads JS from different domains, so mention Content Security Policy (CSP) to prevent XSS 
   // nginx 
   add_header Content-Security-Policy "script-src 'self' https://checkout-mfe.example.com https://auth-mfe.example.com;";

 - CORS allow the shell domain 
 - Authentication & authorization handled by host (using HttpOnly cookie). Remotes consumes token via shared service. 
    // host exposes
    getAccessToken: () => store.getState().auth.accessToken

 - Version pinning to avoid unexpected/malicious remote updates 

